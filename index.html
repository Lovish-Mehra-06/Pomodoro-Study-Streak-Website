<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Study Streak Tracker</title>
		<style>
			:root {
				--bg: #f5f7fb;
				--card: #ffffff;
				--muted: #8b95a3;
				--accent: #6c8ef5;
				--accent-2: #9bd1a9;
				--glass: rgba(255, 255, 255, 0.6);
				--radius: 14px;
				font-family: Inter, ui-sans-serif, system-ui, -apple-system,
					"Segoe UI", Roboto, "Helvetica Neue", Arial;
			}
			* {
				box-sizing: border-box;
			}
			body {
				margin: 0;
				min-height: 100vh;
				background: linear-gradient(180deg, #f7fbff 0%, #f5f7fb 100%);
				color: #213045;
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 24px;
			}

			.container {
				width: 100%;
				max-width: 1100px;
				display: grid;
				grid-template-columns: 1fr 360px;
				gap: 20px;
				align-items: start;
			}

			@media (max-width: 900px) {
				.container {
					grid-template-columns: 1fr;
					padding-bottom: 40px;
				}
			}

			.card {
				background: var(--card);
				border-radius: var(--radius);
				box-shadow: 0 6px 18px rgba(33, 48, 69, 0.06);
				padding: 18px;
			}

			/* Left / main column */
			.main {
				display: flex;
				flex-direction: column;
				gap: 16px;
			}

			.timer-card {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 12px;
				padding: 28px;
			}

			.timer-display {
				font-size: 64px;
				font-weight: 700;
				letter-spacing: 2px;
				color: #111827;
				background: linear-gradient(
					90deg,
					rgba(108, 142, 245, 0.08),
					rgba(155, 209, 169, 0.06)
				);
				padding: 18px 30px;
				border-radius: 12px;
				min-width: 220px;
				text-align: center;
			}

			.mode-labels {
				display: flex;
				gap: 10px;
				align-items: center;
			}
			.mode-btn {
				border: 0;
				padding: 8px 12px;
				border-radius: 999px;
				background: transparent;
				cursor: pointer;
				color: var(--muted);
				font-weight: 600;
				transition: all 0.18s;
			}
			.mode-btn.active {
				background: linear-gradient(
					90deg,
					var(--accent),
					var(--accent-2)
				);
				color: white;
				box-shadow: 0 6px 18px rgba(108, 142, 245, 0.14);
			}

			.controls {
				display: flex;
				gap: 10px;
				align-items: center;
				margin-top: 6px;
			}
			.btn {
				border: 0;
				padding: 10px 14px;
				border-radius: 10px;
				font-weight: 700;
				cursor: pointer;
				background: var(--accent);
				color: white;
				box-shadow: 0 6px 12px rgba(108, 142, 245, 0.12);
			}
			.btn.secondary {
				background: transparent;
				color: var(--accent);
				border: 1px solid rgba(108, 142, 245, 0.12);
				box-shadow: none;
			}
			.small {
				padding: 8px 10px;
				font-weight: 600;
				border-radius: 10px;
			}

			.settings {
				display: flex;
				gap: 12px;
				flex-wrap: wrap;
				align-items: center;
				justify-content: center;
				margin-top: 8px;
			}
			.field {
				display: flex;
				flex-direction: column;
				gap: 6px;
				min-width: 120px;
				text-align: center;
			}
			.field input[type="number"] {
				padding: 8px 10px;
				border-radius: 8px;
				border: 1px solid #e6e9ef;
				text-align: center;
				font-weight: 700;
				font-size: 14px;
			}
			label {
				font-size: 13px;
				color: var(--muted);
			}

			.progress-wrap {
				margin-top: 10px;
				width: 100%;
			}
			.progress {
				height: 12px;
				background: #eef2ff;
				border-radius: 999px;
				overflow: hidden;
			}
			.progress > i {
				display: block;
				height: 100%;
				width: 0%;
				border-radius: 999px;
				background: linear-gradient(
					90deg,
					var(--accent),
					var(--accent-2)
				);
				transition: width 0.6s ease;
			}

			.motiv {
				text-align: center;
				padding: 10px 12px;
				font-weight: 600;
				color: var(--muted);
				font-size: 14px;
				margin-top: 6px;
			}

			/* Right column: stats and music */
			.side {
				display: flex;
				flex-direction: column;
				gap: 14px;
			}

			.stats-grid {
				display: grid;
				grid-template-columns: repeat(2, 1fr);
				gap: 10px;
			}
			.stat {
				padding: 12px;
				border-radius: 12px;
				background: linear-gradient(
					180deg,
					rgba(240, 248, 255, 0.6),
					rgba(255, 255, 255, 0.6)
				);
				box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6),
					0 4px 12px rgba(33, 48, 69, 0.04);
				min-height: 70px;
				display: flex;
				flex-direction: column;
				justify-content: center;
			}
			.stat .value {
				font-size: 20px;
				font-weight: 800;
				color: #0f1724;
			}
			.stat .label {
				font-size: 12px;
				color: var(--muted);
				margin-top: 4px;
				font-weight: 700;
			}

			.sessions-card {
				padding: 12px;
				border-radius: 12px;
			}
			.session-list {
				max-height: 220px;
				overflow: auto;
				padding-right: 6px;
				margin-top: 8px;
			}
			.session-item {
				display: flex;
				justify-content: space-between;
				gap: 8px;
				padding: 8px;
				border-radius: 10px;
				align-items: center;
				margin-bottom: 8px;
				background: linear-gradient(
					90deg,
					rgba(246, 250, 255, 0.9),
					rgba(255, 255, 255, 0.9)
				);
			}
			.session-item .meta {
				color: var(--muted);
				font-weight: 700;
				font-size: 13px;
			}
			.session-item .time {
				font-weight: 800;
				color: #213045;
			}

			.music {
				display: flex;
				gap: 8px;
				align-items: center;
				justify-content: space-between;
				padding: 12px;
				border-radius: 12px;
			}
			.music-controls {
				display: flex;
				gap: 8px;
				align-items: center;
			}
			.music .btn {
				padding: 8px 10px;
				font-size: 14px;
				border-radius: 8px;
			}

			footer {
				text-align: center;
				color: var(--muted);
				font-size: 13px;
				margin-top: 12px;
			}

			/* small helper */
			.muted {
				color: var(--muted);
				font-weight: 700;
				font-size: 13px;
			}

			/* tiny animation */
			.pulse {
				animation: pulse 2s infinite;
			}
			@keyframes pulse {
				0% {
					transform: scale(1);
				}
				50% {
					transform: scale(1.02);
				}
				100% {
					transform: scale(1);
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div class="main card">
				<div class="timer-card">
					<div class="mode-labels" role="tablist">
						<button class="mode-btn active" data-mode="focus">
							Focus
						</button>
						<button class="mode-btn" data-mode="break">
							Break
						</button>
					</div>

					<div class="timer-display" id="timerDisplay">25:00</div>

					<div class="controls">
						<button class="btn" id="startBtn">Start</button>
						<button class="btn secondary" id="pauseBtn">
							Pause
						</button>
						<button class="btn secondary" id="resetBtn">
							Reset
						</button>
					</div>

					<div class="settings">
						<div class="field">
							<label>Focus (min)</label>
							<input
								type="number"
								id="focusInput"
								min="1"
								max="180"
								value="25" />
						</div>
						<div class="field">
							<label>Break (min)</label>
							<input
								type="number"
								id="breakInput"
								min="1"
								max="60"
								value="5" />
						</div>
						<div class="field">
							<label>Sessions / cycle</label>
							<input
								type="number"
								id="sessionsPerCycle"
								min="1"
								max="8"
								value="4" />
						</div>
						<div class="field">
							<label>Auto-start next?</label>
							<select id="autoNext">
								<option value="false">No</option>
								<option value="true">Yes</option>
							</select>
						</div>
					</div>

					<div class="progress-wrap" aria-hidden="true">
						<div class="progress" title="Cycle progress">
							<i id="progressBar"></i>
						</div>
					</div>

					<div class="motiv" id="motivText">
						Let's build a streak â€” one session at a time ðŸ’ª
					</div>
				</div>

				<div class="card" style="padding: 14px">
					<h3 style="margin: 0 0 8px 0">How it works</h3>
					<p class="muted" style="margin: 0">
						Press <strong>Start</strong> to begin a focus session.
						When a focus session completes it is recorded. Finish
						<strong>sessions per cycle</strong> to fill the progress
						bar. Streaks are based on local dates.
					</p>
				</div>
			</div>

			<aside class="side">
				<div class="card stats-card">
					<h3 style="margin: 0 0 12px 0">Stats</h3>
					<div class="stats-grid">
						<div class="stat">
							<div class="value" id="totalTime">0 min</div>
							<div class="label">Total study time</div>
						</div>
						<div class="stat">
							<div class="value" id="currentStreak">0</div>
							<div class="label">Current day streak</div>
						</div>
						<div class="stat">
							<div class="value" id="longestStreak">0</div>
							<div class="label">Longest streak (days)</div>
						</div>
						<div class="stat">
							<div class="value" id="weeklyStreak">0</div>
							<div class="label">Current weekly streak</div>
						</div>
					</div>
				</div>

				<div class="card sessions-card">
					<h3 style="margin: 0 0 8px 0">Recent Sessions</h3>
					<div class="session-list" id="sessionList">
						<!-- items -->
					</div>
					<div
						style="
							display: flex;
							gap: 8px;
							margin-top: 8px;
							justify-content: space-between;
							align-items: center;
						">
						<button class="small btn secondary" id="clearSessions">
							Clear
						</button>
						<div class="muted" id="savedMsg">Saved locally</div>
					</div>
				</div>

				<div class="card music">
					<div style="flex: 1">
						<div style="font-weight: 800">Focus Music</div>
						<div
							class="muted"
							style="font-size: 13px; margin-top: 6px">
							Drop a file named <code>lofi.mp3</code> in this
							folder to enable
						</div>
					</div>
					<div class="music-controls">
						<button class="btn" id="musicToggle">Play</button>
						<input
							id="volume"
							type="range"
							min="0"
							max="1"
							step="0.05"
							value="0.5" />
					</div>
					<audio id="audio" preload="none" loop>
						<source src="lofi.mp3" type="audio/mp3" />
						<!-- Optional: if no file, audio stays empty and play is disabled -->
					</audio>
				</div>

				<footer class="card" style="padding: 12px">
					<div style="font-weight: 800">Study Streak Tracker</div>
					<div class="muted" style="margin-top: 6px">
						Made with focus âœ¨
					</div>
				</footer>
			</aside>
		</div>

		<script>
			// Study Streak Tracker - Single file app
			(function () {
				// Elements
				const timerDisplay = document.getElementById("timerDisplay");
				const startBtn = document.getElementById("startBtn");
				const pauseBtn = document.getElementById("pauseBtn");
				const resetBtn = document.getElementById("resetBtn");
				const focusInput = document.getElementById("focusInput");
				const breakInput = document.getElementById("breakInput");
				const modeBtns = document.querySelectorAll(".mode-btn");
				const progressBar = document.getElementById("progressBar");
				const motivText = document.getElementById("motivText");
				const sessionsPerCycleInput =
					document.getElementById("sessionsPerCycle");
				const autoNextSelect = document.getElementById("autoNext");

				const totalTimeEl = document.getElementById("totalTime");
				const currentStreakEl =
					document.getElementById("currentStreak");
				const longestStreakEl =
					document.getElementById("longestStreak");
				const weeklyStreakEl = document.getElementById("weeklyStreak");
				const sessionListEl = document.getElementById("sessionList");
				const clearSessionsBtn =
					document.getElementById("clearSessions");

				const audio = document.getElementById("audio");
				const musicToggle = document.getElementById("musicToggle");
				const volume = document.getElementById("volume");

				// State
				const STORAGE_KEY = "sst_data_v1";
				let state = {
					mode: "focus", // 'focus' or 'break'
					running: false,
					remaining: 25 * 60,
					timerInterval: null,
					sessionsPerCycle:
						parseInt(sessionsPerCycleInput.value, 10) || 4,
					completedThisCycle: 0,
					sessions: [], // each {ts, durationSeconds, type:'focus'}
				};

				// Motivational messages
				const MOTIVS = [
					"Nice work â€” one session down!",
					"Keep going â€” momentum builds habits!",
					"Focus mode: mastered âœ¨",
					"You're stacking wins â€” keep it up!",
					"Great job! Take a mindful breath.",
					"Consistency > intensity. Well done!",
				];

				// Utilities
				function load() {
					const raw = localStorage.getItem(STORAGE_KEY);
					if (raw) {
						try {
							const parsed = JSON.parse(raw);
							if (parsed && parsed.sessions) {
								state.sessions = parsed.sessions;
								state.completedThisCycle =
									parsed.completedThisCycle || 0;
							}
						} catch (e) {}
					}
					updateUIFromSettings();
					renderSessions();
					recalcStats();
					updateProgressBar();
				}

				function save() {
					const payload = {
						sessions: state.sessions,
						completedThisCycle: state.completedThisCycle,
					};
					localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
				}

				function secondsToMMSS(s) {
					s = Math.max(0, Math.round(s));
					const mm = Math.floor(s / 60)
						.toString()
						.padStart(2, "0");
					const ss = (s % 60).toString().padStart(2, "0");
					return `${mm}:${ss}`;
				}

				function updateTimerDisplay() {
					const text = secondsToMMSS(state.remaining);
					timerDisplay.textContent = text;
				}

				function setMode(mode, resetRemaining = true) {
					state.mode = mode;
					modeBtns.forEach((b) =>
						b.classList.toggle("active", b.dataset.mode === mode)
					);
					if (resetRemaining) {
						const minutes =
							mode === "focus"
								? parseInt(focusInput.value, 10) || 25
								: parseInt(breakInput.value, 10) || 5;
						state.remaining = minutes * 60;
						updateTimerDisplay();
					}
				}

				function startTimer() {
					if (state.running) return;
					state.running = true;
					startBtn.textContent = "Running";
					startBtn.disabled = true;
					pauseBtn.disabled = false;
					state.timerInterval = setInterval(() => {
						state.remaining -= 1;
						updateTimerDisplay();
						if (state.remaining <= 0) {
							// session finished
							clearInterval(state.timerInterval);
							state.timerInterval = null;
							state.running = false;
							startBtn.disabled = false;
							startBtn.textContent = "Start";
							onTimerComplete();
						}
					}, 1000);
				}

				function pauseTimer() {
					if (!state.running) return;
					clearInterval(state.timerInterval);
					state.timerInterval = null;
					state.running = false;
					startBtn.disabled = false;
					startBtn.textContent = "Start";
				}

				function resetTimer() {
					pauseTimer();
					setMode(state.mode, true);
					motivText.textContent = "Timer reset â€” ready when you are.";
				}

				function onTimerComplete() {
					// If focus session completes, record it
					if (state.mode === "focus") {
						const now = Date.now();
						const durationSec =
							(parseInt(focusInput.value, 10) || 25) * 60;
						state.sessions.unshift({
							ts: now,
							duration: durationSec,
							type: "focus",
						});
						// keep a reasonable cap
						if (state.sessions.length > 1000)
							state.sessions.length = 1000;
						state.completedThisCycle =
							(state.completedThisCycle || 0) + 1;
						showMotivation();
					} else {
						// break finished
						motivText.textContent =
							"Break ended â€” ready for another focus?";
					}
					save();
					renderSessions();
					recalcStats();
					updateProgressBar();

					// Auto switch modes
					const nextMode = state.mode === "focus" ? "break" : "focus";
					setMode(nextMode, true);

					const autoStart = autoNextSelect.value === "true";
					if (autoStart) startTimer();
				}

				function showMotivation() {
					const msg =
						MOTIVS[Math.floor(Math.random() * MOTIVS.length)];
					motivText.textContent = msg;
				}

				function updateProgressBar() {
					const perCycle = Math.max(
						1,
						parseInt(sessionsPerCycleInput.value, 10) || 4
					);
					const pct = Math.min(
						100,
						((state.completedThisCycle % perCycle) / perCycle) * 100
					);
					progressBar.style.width = pct + "%";
					// show small pulse when almost full
					if (pct >= 75) timerDisplay.classList.add("pulse");
					else timerDisplay.classList.remove("pulse");
				}

				// Renders list of recent sessions
				function renderSessions() {
					sessionListEl.innerHTML = "";
					if (!state.sessions.length) {
						sessionListEl.innerHTML =
							'<div class="muted" style="padding:8px">No sessions yet â€” do one to start your streak!</div>';
						return;
					}
					state.sessions.slice(0, 40).forEach((s) => {
						const d = new Date(s.ts);
						const item = document.createElement("div");
						item.className = "session-item";
						const title = document.createElement("div");
						title.innerHTML = `<div style="font-weight:800">${d.toLocaleDateString()} <span class="muted" style="font-weight:700"> ${d.toLocaleTimeString(
							[],
							{ hour: "2-digit", minute: "2-digit" }
						)}</span></div>`;
						const right = document.createElement("div");
						right.innerHTML = `<div class="time">${Math.round(
							s.duration / 60
						)} min</div><div class="meta">${s.type}</div>`;
						item.appendChild(title);
						item.appendChild(right);
						sessionListEl.appendChild(item);
					});
				}

				// Stats / streak calculations
				function recalcStats() {
					// total study time (minutes)
					const totalSeconds = state.sessions.reduce(
						(a, b) => a + (b.type === "focus" ? b.duration : 0),
						0
					);
					const totalMinutes = Math.round(totalSeconds / 60);
					totalTimeEl.textContent = totalMinutes + " min";

					// Build set of dates (yyyy-mm-dd)
					const dateSet = new Set(
						state.sessions.map((s) => {
							const d = new Date(s.ts);
							const y = d.getFullYear();
							const m = (d.getMonth() + 1)
								.toString()
								.padStart(2, "0");
							const day = d.getDate().toString().padStart(2, "0");
							return `${y}-${m}-${day}`;
						})
					);

					// Longest consecutive daily streak (in days)
					const allDates = Array.from(dateSet).sort(); // asc
					const dateNums = allDates
						.map((ds) => {
							const [y, m, d] = ds.split("-").map(Number);
							return new Date(y, m - 1, d).getTime();
						})
						.sort((a, b) => a - b);

					let longest = 0;
					let current = 0;
					let prev = null;
					dateNums.forEach((ts) => {
						if (prev === null) {
							current = 1;
						} else {
							const diff = (ts - prev) / (1000 * 60 * 60 * 24);
							if (diff === 1) current++;
							else current = 1;
						}
						if (current > longest) longest = current;
						prev = ts;
					});

					longestStreakEl.textContent = longest;

					// Current streak: count consecutive days up to today
					const today = new Date();
					today.setHours(0, 0, 0, 0);
					let cur = 0;
					for (let i = 0; ; i++) {
						const d = new Date(
							today.getTime() - i * 24 * 60 * 60 * 1000
						);
						const key = `${d.getFullYear()}-${(d.getMonth() + 1)
							.toString()
							.padStart(2, "0")}-${d
							.getDate()
							.toString()
							.padStart(2, "0")}`;
						if (dateSet.has(key)) cur++;
						else break;
					}
					currentStreakEl.textContent = cur;

					// Weekly streak: compute set of ISO week keys (year-weeknum)
					const weekSet = new Set(
						state.sessions.map((s) => {
							const d = new Date(s.ts);
							const [y, w] = getYearWeek(d);
							return `${y}-W${w}`;
						})
					);
					// compute current consecutive weekly streak ending this week
					const now = new Date();
					const [curYear, curWeek] = getYearWeek(now);
					let weeklyStreak = 0;
					let checkYear = curYear,
						checkWeek = curWeek;
					while (true) {
						const key = `${checkYear}-W${checkWeek}`;
						if (weekSet.has(key)) {
							weeklyStreak++;
						} else break;
						// step back one week
						const prevWeekDate = getDateFromYearWeek(
							checkYear,
							checkWeek
						);
						const prev = new Date(
							prevWeekDate.getTime() - 7 * 24 * 60 * 60 * 1000
						);
						const parts = getYearWeek(prev);
						checkYear = parts[0];
						checkWeek = parts[1];
					}
					weeklyStreakEl.textContent = weeklyStreak;

					// update saved message
					document.getElementById("savedMsg").textContent =
						"Saved locally";
				}

				// ISO week helpers
				function getYearWeek(d) {
					// copy
					const date = new Date(d.getTime());
					date.setHours(0, 0, 0, 0);
					// Thursday in current week decides the year.
					date.setDate(
						date.getDate() + 3 - ((date.getDay() + 6) % 7)
					);
					const week1 = new Date(date.getFullYear(), 0, 4);
					const weekNo =
						1 +
						Math.round(
							((date.getTime() - week1.getTime()) / 86400000 -
								3 +
								((week1.getDay() + 6) % 7)) /
								7
						);
					return [date.getFullYear(), weekNo];
				}
				function getDateFromYearWeek(y, w) {
					const simple = new Date(y, 0, 1 + (w - 1) * 7);
					const dow = simple.getDay();
					const ISOdow = dow <= 0 ? 7 : dow;
					const diff = simple.getDate() - ISOdow + 1 + 3;
					return new Date(y, 0, diff);
				}

				// Event listeners
				startBtn.addEventListener("click", () => {
					startTimer();
				});
				pauseBtn.addEventListener("click", () => {
					pauseTimer();
				});
				resetBtn.addEventListener("click", () => {
					resetTimer();
				});

				modeBtns.forEach((b) =>
					b.addEventListener("click", (e) => {
						setMode(b.dataset.mode, true);
					})
				);

				// Update state on settings change
				focusInput.addEventListener("change", () => {
					if (state.mode === "focus" && !state.running)
						setMode("focus", true);
				});
				breakInput.addEventListener("change", () => {
					if (state.mode === "break" && !state.running)
						setMode("break", true);
				});

				sessionsPerCycleInput.addEventListener("change", () => {
					state.sessionsPerCycle =
						parseInt(sessionsPerCycleInput.value, 10) || 4;
					updateProgressBar();
					save();
				});

				autoNextSelect.addEventListener("change", () => {
					/* no-op */
				});

				// Clear sessions
				clearSessionsBtn.addEventListener("click", () => {
					if (!confirm("Clear all saved sessions?")) return;
					state.sessions = [];
					state.completedThisCycle = 0;
					save();
					renderSessions();
					recalcStats();
					updateProgressBar();
				});

				// Music player handlers
				musicToggle.addEventListener("click", () => {
					if (!audio.querySelector("source")) {
						alert(
							'No audio source found. Add a file named "lofi.mp3" in the same folder to enable music.'
						);
						return;
					}
					if (audio.paused) {
						audio.volume = parseFloat(volume.value);
						audio.play().catch(() => {
							alert("Autoplay blocked â€” click play again");
						});
						musicToggle.textContent = "Stop";
					} else {
						audio.pause();
						audio.currentTime = 0;
						musicToggle.textContent = "Play";
					}
				});
				volume.addEventListener("input", () => {
					audio.volume = parseFloat(volume.value);
				});

				// On focus session completion, also increment completedThisCycle and reset when cycle completes
				// We already increased completedThisCycle earlier. Let's add logic to reset after reaching sessionsPerCycle.
				const originalOnTimerComplete = onTimerComplete;
				// (We used the function directly â€” but we'll just ensure cycle reset logic in onTimerComplete itself)
				// After recording session and recalc, check cycle:
				function handleCycleAfterCompletion() {
					const perCycle = Math.max(
						1,
						parseInt(sessionsPerCycleInput.value, 10) || 4
					);
					if (state.completedThisCycle >= perCycle) {
						// cycle completed
						state.completedThisCycle = 0;
						motivText.textContent =
							"Cycle complete! Take a longer break or celebrate ðŸŽ‰";
					}
					save();
				}

				// wrap to include cycle handling
				function onTimerComplete() {
					// If focus session completes, record it
					if (state.mode === "focus") {
						const now = Date.now();
						const durationSec =
							(parseInt(focusInput.value, 10) || 25) * 60;
						state.sessions.unshift({
							ts: now,
							duration: durationSec,
							type: "focus",
						});
						if (state.sessions.length > 1000)
							state.sessions.length = 1000;
						state.completedThisCycle =
							(state.completedThisCycle || 0) + 1;
						showMotivation();
					} else {
						motivText.textContent =
							"Break ended â€” ready for another focus?";
					}
					save();
					renderSessions();
					recalcStats();
					updateProgressBar();

					// cycle handling
					handleCycleAfterCompletion();

					// Auto switch modes
					const nextMode = state.mode === "focus" ? "break" : "focus";
					setMode(nextMode, true);

					const autoStart = autoNextSelect.value === "true";
					if (autoStart) startTimer();
				}

				// Initialize UI values & load state
				function updateUIFromSettings() {
					focusInput.value = focusInput.value || "25";
					breakInput.value = breakInput.value || "5";
					sessionsPerCycleInput.value =
						sessionsPerCycleInput.value || "4";
					setMode("focus", true);
				}

				// Initialize
				load();

				// small safety: ensure pause btn disabled initially
				pauseBtn.disabled = true;

				// expose a small debugging console on double-click timer
				timerDisplay.addEventListener("dblclick", () => {
					alert("Sessions stored: " + state.sessions.length);
				});

				// on unload: save
				window.addEventListener("beforeunload", () => save());
			})();
		</script>
	</body>
</html>
